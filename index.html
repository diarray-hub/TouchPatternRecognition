<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>TouchTracker</title>
  <style>
    *{
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      position: relative;
    }
    .flex{
      display: flex;
      align-items: center;
      justify-content: center;
    }
    body{
      width: 100vw;
      height: 100vh;
      background: #121212;
      --baseCol: #00cb88;
    }
    .lockBox,
    .lockBox *{
      user-select: none;
      -webkit-user-select: none;
    }
    .lockBox{
      width: 350px;
      height: 450px;
      border: 1px solid #00cbff;
      display: flex;
      justify-content: space-between;
      align-content: space-between;
      flex-flow: row wrap;
      z-index: 1;
      border-radius: 5px;
    }
    .dot{
      width: 10px;
      height: 10px;
      border: 1px solid #00cbff;
      margin: 40px;
      border-radius: 50%;
      box-shadow: 0 0 30px var(--baseCol);
    }
    .dot.active{
      animation: on .25s cubic-bezier(0, 2.24, 0.2, 2.23) forwards;
      transform: scale(0);
      pointer-events: none;
      border: none;
    }
    .dot i{pointer-events: none;opacity: 0;}

    @keyframes on{
      100%{
        background: var(--baseCol);
        transform: scale(1);
        box-shadow: 0 0 30px 5px var(--baseCol);
      }
    }
    .dotArea{
      position: absolute;
      width: 40px;
      height: 40px;
      border-radius: 50%;
      left: -16px;top: -16px;
      cursor: pointer;
    }
    .lockBox svg {
      width: 100%;
      height: 100%;
      position: absolute;
      pointer-events: none;
      z-index: -1;
      fill: none;
      stroke: var(--baseCol);
    }

    h2{
        color: #fff;
        font-style: italic;
        position: absolute;
        text-align: center;
        top: 80px;
    }
  </style>
</head>
<body class="flex">
  <h2>Rely dots as you feel</h2>
  <div class="lockBox box">
    <svg>
      <path d=""></path>
    </svg>
  </div>
  <script>
    var log=console.log;
    function op(elem){return document.querySelector(elem)}
    function opp(elem){return document.querySelectorAll(elem)}

    var lockBox=op('.lockBox');
    for(var a=0; a< 15; a++){
    lockBox.insertAdjacentHTML("afterbegin",`<div class="dot"><div class="dotArea" ontouchstart="TouchStart(this)"><i>${a}</i></div></div>`)
    }

    var startDot,
    svg=op("svg"),
    dots=opp(".dot"),
    lineData="M",
    tempLineData,
    //svgPath=op('svg path'),
    inputData="";

    function end(){
        document.body.style.setProperty('--baseCol',(inputData.length === 5)?"#0f0":"#f00");

        startDot=undefined;
        lineData="M";
        inputData="";
        tempLineData=undefined;

        setTimeout(()=>{
            opp('.dot.active').forEach(val=>{val.classList.remove('active')})
            svgPath.setAttribute("d",'');
            document.body.style.setProperty('--baseCol',"#00cbff");
        },500)
    }

    function TouchStart(elem){
        startDot=elem;
        document.addEventListener('touchmove', moving);
        addEvToMouseEnter();
        lineData+=`${startDot.parentElement.offsetLeft +5},${startDot.parentElement.offsetTop +5}`;
        makeLine();
        startDot.classList.add("active")
    }
    
    document.ontouchend=function (){
        document.removeEventListener('touchmove', moving);
        removeEvToMouseEnter();
        tempLineData=''
        updateLine();
        end()
    }

    function moving(e){
        makeLineWhileMoving(e.touches[0].clientX,e.touches[0].clientY)
    }

    function makeLineWhileMoving(x,y){
        var x=Math.floor(x - lockBox.getBoundingClientRect().left);
        var y=Math.floor(y - lockBox.getBoundingClientRect().top);

        tempLineData=" L"+x+','+y;

        updateLine()
    }

    function makeLine(e=startDot){
        e.target=startDot;
        var dot=e.target.parentElement;
        dot.classList.add('active');
        var x=dot.getBoundingClientRect().left,
        y=dot.getBoundingClientRect().top;
        inputData+=dot.innerText;
    
        makeLineWhileMoving(x,y)
        lineData+=tempLineData;
    } 

    function addEvToMouseEnter(){
        opp(".dotArea").forEach(val=>{
            val.addEventListener("touchstart",makeLine);
        })
    }

    function removeEvToMouseEnter(){
        opp(".dotArea").forEach(val=>{
            val.removeEventListener("touchstart",makeLine);
        })
    }

    function updateLine(){
        svgPath.setAttribute("d",lineData+tempLineData);
    }
  </script>
</body>
<script src="https://code.jquery.com/jquery-2.2.4.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@1.5.2/dist/tf.min.js"></script>
<script>
  class TrackingSession {
    /*
    This TrackingSession offers us a general way to collect data from the screen through the app
    The most important method there is the *handle* method through which we collect data like position and timestamp
    */
    // To track the active touch
    activeTouch = {}
    // To store all the records
    records = []
    // Our app are not going to use the whole screen. This will set the app screen dimensions
    screenScale = window.devicePixelRatio
    screenSize = [
        screen.width,
        screen.height
    ]
    // The handle method
    handle(event, touches) {
        if (touches.length !== 1) {
            // Ignore if there are multiple touches on the screen
            return
        }
        const touch = touches.item(0)
        switch (event) {
            case "start":
                const id = Math.floor(1e8 * Math.random()) + ""
                this.activeTouch[touch.identifier] = id
                this.records.push(new TouchRecord(event, touch, id))
                break
            case "move":
                if (this.activeTouch[touch.identifier]) {
                    this.records.push(new TouchRecord(event, touch, this.activeTouch[touch.identifier]))
                }
                break
            case "end":
                if (this.activeTouch[touch.identifier]) {
                    this.records.push(new TouchRecord(event, touch, this.activeTouch[touch.identifier]))
                    delete this.activeTouch[touch.identifier]
                    this.export()
                    this.activeTouch = {}
                    this.records = []
                }
                break
        }
        /* 
        //This block has been add during data collect take care to declare the endcounter attribute in order to re-use it
        if(this.endcounter === 25){
            this.export()
            this.endcounter = 0
            this.activeTouch = {}
            this.records = []
        }*/
    }
    // Recognition
    recognizeUser() {
        tf.loadLayersModel('Models/tfjs_model/model.json').then(function(model) {
          window.model = model;
        });
        const data = preprocess(this.touchTracks);
        var predict = function(input) {
          if (window.model) {
            window.model.predict(data).then(function(scores){
              scores = scores[0][0];
              if (scores >= 0.90){
                window.location.href = "https://diarray-hub.github.io/TouchPatternRecognition/theapp/Welcome.html";
              }
              else {
                window.location.href = "https://diarray-hub.github.io/TouchPatternRecognition/theapp/Error.html";
              }
            });
          } else {
            // The model takes a bit to load, if we are too fast, wait
            setTimeout(function(){predict(input)}, 50);
          }
        }
    }
    
    // This method will use the *download* function defined below to export data in .json file format
    export() {
        const name = "TouchTracker_Export";
        const touchTrackings = {};
        let currentTouchId;
        let currentTouchTimestamp;
        let currentPosition;
        let lastPosition;
        let currentSpeed;
        let currentDirection;
    
        // Process the touch records to create touch tracking objects
        this.records.forEach(record => {
            if (record.event === "start") {
                currentTouchId = record.touchId;
                currentTouchTimestamp = record.timestamp;
                currentPosition = record.position;
                touchTrackings[currentTouchId] = {id: currentTouchId, positions: [currentPosition], 
                    speeds: [], directions: [], startTimestamp: currentTouchTimestamp};
            } else if (record.event === "move") {
                lastPosition = currentPosition;
                currentPosition = record.position;
                currentSpeed = calculateSpeed(currentPosition, lastPosition, record.timestamp, currentTouchTimestamp);
                currentTouchTimestamp = record.timestamp;
                currentDirection = calculateDirection(currentPosition, lastPosition);
                touchTrackings[currentTouchId].positions.push(currentPosition);
                touchTrackings[currentTouchId].speeds.push(currentSpeed);
                touchTrackings[currentTouchId].directions.push(currentDirection);
            } else if (record.event === "end") {
                touchTrackings[currentTouchId].endTimestamp = record.timestamp;
            }
        });
    
        // Create an array of touch tracking objects
        const touchTrackingsArray = Object.values(touchTrackings);
        this.touchTracks = touchTrackingsArray;
    
        // Generate the output object
        const output = {
            name: name,
            duration: touchTrackingsArray[0].endTimestamp - touchTrackingsArray[0].startTimestamp,
            touchTrackings: touchTrackingsArray,
            screenSize: this.screenSize,
            screenScale: this.screenScale
        };

        this.recognizeUser();
        download(JSON.stringify(output, null, 2), name + " " + new Date().toLocaleString(), "application/json");

        function calculateSpeed(currentPosition, lastPosition, timestamp, lastimestamp) {
            const distance = Math.sqrt((currentPosition[0] - lastPosition[0]) ** 2 + (currentPosition[1] - lastPosition[1]) ** 2);
            const timeElapsed = timestamp - lastimestamp;
            return distance / timeElapsed; // Eucludian speed calculus
        }
    
        function calculateDirection(currentPosition, lastPosition) {
            /*
            Note that the angle returned by Math.atan2 is not the same as the direction in degrees (i.e. north, south, east, west). Instead, 
            it represents the angle between the two points in the coordinate system, with the positive x-axis as the reference.
            */
            const deltaX = currentPosition[0] - lastPosition[0];
            const deltaY = currentPosition[1] - lastPosition[1];
            return Math.atan2(deltaY, deltaX);
        }
    }
}

class TouchRecord {
    /*
    A TouchRecord class that we'll use as represention of the collected data. 
    This class' structure represent how data will look like in the .json file
    */
    touchId
    event
    position
    timestamp

    constructor(event, touch, id) {
        this.touchId = id
        this.event = event
        const topOffset = screen.height - window.innerHeight
        this.position = [
            touch.screenX,
            touch.screenY + topOffset
        ]
        this.timestamp = new Date().getTime() / 1000
    }
}

// Implement a part of preprocessing.py stats_summary function in JS
function preprocess(touchTrackingArray){
    var touch = touchTrackingArray[0],
        positionsX = [],
        positionY = [],
        speeds = touch.speeds,
        directions = touch.directions,
        latency = touch.endTimestamp - touch.startTimestamp
    touch.positions.forEach(position => {
        positionsX.push(position[0])
        positionY.push(position[1])
    });
    fields = [positionX, positionY, speeds, directions];
    // Calculate the features
    const features = fields.map(field => {
        const mean = field.reduce((a, b) => a + b) / field.length;
        const stdDev = Math.sqrt(field.map(x => Math.pow(x - mean, 2)).reduce((a, b) => a + b) / field.length);
        const min = Math.min(...field);
        const max = Math.max(...field);
        const range = max - min;
        return [mean, stdDev, min, max, range];
    });
    
    // Flatten the features into a single list
    const flattenedFeatures = features.reduce((acc, val) => acc.concat(val), []);
    flattenedFeatures.push(latency);
    return [flattenedFeatures]
}

// Defining a function that will allows us to export collected data in .json file from the browser
function download(data, filename, type) {
    var file = new Blob([data], {type: type});
    if (window.navigator.msSaveOrOpenBlob) // IE10+
        window.navigator.msSaveOrOpenBlob(file, filename);
    else { // Others
        var a = document.createElement("a"),
                url = URL.createObjectURL(file);
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(function() {
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);  
        }, 0); 
    }
}

// Creating a instance of our Trackingsession class
const session = new TrackingSession()

/*
    This code adds an event listener to the touch events of the body element in an HTML document. 
    The function that is passed as the second argument to addEventListener will be executed whenever the touchstart event is fired on the body element.
    *touchstart*, *touchmove* and *touchend* are  built-in JavaScript events that is triggered when a user touches the screen with their finger or stylus. 
    It is specifically designed for touchscreens and is not triggered by mouse clicks or other input methods.
    The preventDefault() function is called to prevent the default action associated with the touchstart event from occurring. 
    In this case, the default action is to scroll the page when the user touches the screen, and calling preventDefault() 
    will prevent this from happening.
    The e.changedTouches property in the code represents an array of touch points that have changed since the last event. 
    This can include touches that have been added, moved, or removed from the screen.
    When the passive option is set to false, it indicates that the event listener will call preventDefault() on the event object, 
    which will prevent the default behavior of the touchmove event from occurring. 
    Note that setting passive to false can potentially cause performance issues on mobile devices, 
    so it is generally recommended to use this option only when necessary.
*/
document.body.addEventListener('touchstart', function(e){
    e.preventDefault()
    session.handle("start", e.touches)
});

document.body.addEventListener('touchmove', function(e){
    e.preventDefault()
    session.handle("move", e.changedTouches)
}, { passive: false });

document.body.addEventListener('touchend', function(e){
    e.preventDefault()
    console.log(e.changedTouches)
    session.handle("end", e.changedTouches)
});

document.body.addEventListener('touchcancel', function(e){
    e.preventDefault()
    session.handle("end", e.changedTouches)
});
</script>
</html>